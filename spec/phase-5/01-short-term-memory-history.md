# 01: 短期記憶履歴システム

## 目的

チャンネルの短期記憶に履歴機能を追加し、会話の流れをより深く理解できるコンテキストを LLM に提供する。

---

## 概要

### 現状の課題

1. **短期記憶が上書きされる**: 現在の実装では短期記憶は (scope, scope_id, memory_type) で一意に管理され、新しい記憶が生成されると古い記憶は失われる
2. **会話の流れが途切れる**: 直前の短期記憶のみでは、会話の経緯や文脈の変化を追跡できない
3. **ワークスペース短期記憶の冗長性**: チャンネルごとの短期記憶を統合したワークスペース短期記憶は、情報が重複する

### 解決策

1. **バージョン管理**: 短期記憶に `version` フィールドを追加し、履歴として保持
2. **履歴表示**: 直近 5 件の短期記憶履歴をプロンプトに含める
3. **長期記憶への統合**: 新しい短期記憶が保存されたタイミングで長期記憶を更新
4. **ワークスペース短期記憶の廃止**: チャンネルの履歴で十分な情報量を確保

---

## 機能要件

### 1. 短期記憶の履歴化

- チャンネルの短期記憶をバージョン管理で履歴として保持
- Memory エンティティに `version` フィールドを追加
- 一意キーを `(scope, scope_id, memory_type, version)` に変更
- スレッドの短期記憶は従来通り上書き（履歴化しない）

### 2. 短期記憶の更新トリガー

以下の **いずれか** の条件（OR条件）を満たした場合に新しいバージョンを作成：

| トリガー | 条件 | 設定項目 |
|---------|------|---------|
| 会話終了 | 最新メッセージから一定時間経過 | `conversation_idle_seconds: 7200`（2時間） |
| コンテキスト圧迫 | メッセージ数が閾値を超過 | `message_threshold: 50` |

### 3. プロンプトへの履歴表示

- 直近 `max_history_count`（デフォルト: 5）件の短期記憶履歴を表示
- 表示順序: 古い順（時系列）- v1 → v2 → v3 → v4 → v5
- チャンネルごとにグループ化して表示
- プロンプト配置: 長期記憶 → 短期記憶履歴 → 会話履歴

### 4. 長期記憶への統合

- 短期記憶が新バージョンとして保存された直後に長期記憶を更新
- 統合方法: 既存長期記憶 + 新短期記憶を LLM で統合
- チャンネル長期記憶とワークスペース長期記憶の両方を更新

### 5. ワークスペース短期記憶の廃止

- Context から `workspace_short_term_memory` の参照を削除
- テンプレートからワークスペース短期記憶の表示を削除
- 既存の DB データは削除せず残す（参照しないのみ）
- 有効な組み合わせから `(WORKSPACE, SHORT_TERM)` を削除

---

## 非機能要件

### パフォーマンス

- 履歴の取得は最新 N 件を効率的に取得できるよう実装
- 長期記憶統合は短期記憶保存と連続して実行される（LLM 呼び出しが連続）

### データ整合性

- 既存の短期記憶データは `version=1` として扱う（マイグレーション）
- 古い履歴は削除しない（別ツールで対応）

### 後方互換性

- `ChannelMemory.short_term_memory` は最新の短期記憶へのエイリアスとして維持
- テンプレートは履歴がない場合も従来通り動作

---

## 子タスク

| # | タスク | 説明 |
|---|--------|------|
| 01a | [設定項目の追加](./01a-config-extension.md) | ShortTermHistoryConfig の追加 |
| 01b | [Memory エンティティのバージョン対応](./01b-memory-entity-version.md) | version フィールド追加 |
| 01c | [リポジトリの履歴対応](./01c-memory-repository-history.md) | 履歴取得メソッド追加 |
| 01d | [ワークスペース短期記憶廃止](./01d-workspace-short-term-deprecation.md) | WS 短期記憶の参照削除 |
| 01e | [Context の履歴対応](./01e-context-history.md) | short_term_memory_history 追加 |
| 01f | [記憶生成ユースケースの履歴対応](./01f-generate-memory-history.md) | 履歴生成・長期記憶統合 |
| 01g | [テンプレート更新](./01g-template-update.md) | 履歴表示対応 |
| 01h | [統合テスト](./01h-integration-test.md) | 全体の動作確認 |

---

## データフロー

### 短期記憶の更新フロー

```
1. バックグラウンド処理が起動
   │
   ↓
2. 各チャンネルについて更新条件をチェック
   │
   ├─ 条件を満たさない → スキップ
   │
   └─ 条件を満たす（2時間静止 OR 50件メッセージ）
      │
      ↓
3. 短期記憶を生成（LLM 呼び出し）
   │
   ↓
4. 新しいバージョンとして保存
   │  (scope, scope_id, memory_type, version)
   │
   ↓
5. チャンネル長期記憶を更新（LLM 呼び出し）
   │  既存長期記憶 + 新短期記憶 → 新長期記憶
   │
   ↓
6. ワークスペース長期記憶を更新（LLM 呼び出し）
   │  既存WS長期記憶 + 全チャンネル長期記憶 → 新WS長期記憶
   │
   ↓
7. 完了
```

### プロンプト構築フロー

```
1. Context 構築時
   │
   ↓
2. 各チャンネルの短期記憶履歴を取得
   │  find_history_by_scope_and_type(limit=max_history_count)
   │
   ↓
3. ChannelMemory に履歴をセット
   │  short_term_memory_history: list[str]
   │
   ↓
4. テンプレートで履歴を表示
   │
   │  ## #channel-name
   │  ### 歴史（長期記憶）
   │  ...
   │  ### 最近の出来事（短期記憶履歴）
   │  #### 記憶 1
   │  ...
   │  #### 記憶 2
   │  ...
   │
   ↓
5. LLM に送信
```

---

## 設計上の考慮事項

### スレッド短期記憶の扱い

スレッドの短期記憶は履歴化しない理由：

1. スレッドは比較的短命で、履歴を保持する必要性が低い
2. 実装の複雑さを抑える
3. スレッドは独立したトピックなので、履歴よりも最新の要約が重要

### 古い履歴の削除

古い履歴は自動削除しない理由：

1. ストレージコストは比較的低い
2. 履歴の削除ポリシーはユーザーの要件による
3. 別ツール（管理スクリプト等）で必要に応じて対応可能

### 長期記憶統合のタイミング

短期記憶保存直後に統合する理由：

1. 一貫性が高い（短期記憶と長期記憶の同期が保たれる）
2. バックグラウンドの定期実行とは別に、イベント駆動で更新できる
3. LLM 呼び出しは連続するが、更新頻度は 2 時間に 1 回程度なので許容範囲

---

## 完了基準

- [ ] 設定項目 `short_term_history` が追加されている
- [ ] Memory エンティティに `version` フィールドが追加されている
- [ ] リポジトリで履歴を取得できる
- [ ] ワークスペース短期記憶が参照されなくなっている
- [ ] Context に `short_term_memory_history` が含まれている
- [ ] 短期記憶が更新トリガーで新バージョンとして保存される
- [ ] 短期記憶保存後に長期記憶が更新される
- [ ] テンプレートで履歴が表示される
- [ ] 全テストが通過する
